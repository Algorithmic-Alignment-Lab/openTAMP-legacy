import sys
sys.path.insert(0, '../../src/')
import core.util_classes.baxter_constants as const
dom_str = """
# AUTOGENERATED. DO NOT EDIT.
# Configuration file for CAN domain. Blank lines and lines beginning with # are filtered out.

# implicity, all types require a name
Types: Basket, BasketTarget, RobotPose, Robot, EEPose, Obstacle, Washer, WasherPose, Cloth, ClothTarget, Rotation, Can, Region, Edge

# Define the class location of each non-standard attribute type used in the above parameter type descriptions.

Attribute Import Paths: HSR core.util_classes.robots, Vector1d core.util_classes.matrix, Vector2d core.util_classes.matrix, Vector3d core.util_classes.matrix, ArmPose5d core.util_classes.matrix, Table core.util_classes.items, Box core.util_classes.items, Basket core.util_classes.items, Washer core.util_classes.robots, Cloth core.util_classes.items, Can core.util_classes.items, Edge core.util_classes.items

Predicates Import Path: core.util_classes.hsr_predicates

"""

class PrimitivePredicates(object):
    def __init__(self):
        self.attr_dict = {}

    def add(self, name, attrs):
        self.attr_dict[name] = attrs

    def get_str(self):
        prim_str = 'Primitive Predicates: '
        first = True
        for name, attrs in self.attr_dict.iteritems():
            for attr_name, attr_type in attrs:
                pred_str = attr_name + ', ' + name + ', ' + attr_type
                if first:
                    prim_str += pred_str
                    first = False
                else:
                    prim_str += '; ' + pred_str
        return prim_str

pp = PrimitivePredicates()
pp.add('Basket', [('geom', 'Basket'), ('pose', 'Vector3d'), ('rotation', 'Vector3d')])
pp.add('BasketTarget', [('geom', 'Basket'), ('value', 'Vector3d'), ('rotation', 'Vector3d')])
pp.add('Cloth', [('geom', 'Cloth'), ('pose', 'Vector3d'), ('rotation', 'Vector3d')])
pp.add('ClothTarget', [('value', 'Vector3d'), ('rotation', 'Vector3d')])
pp.add('RobotPose', [('value', 'Vector1d'),
                    ('lArmPose', 'ArmPose7d'),
                    ('lGripper', 'Vector1d'),
                    ('rArmPose', 'ArmPose7d'),
                    ('rGripper', 'Vector1d')])
pp.add('Robot', [('geom', 'HSR'),
                ('pose', 'Vector2d'),
                ('arm', 'ArmPose5d'),
                ('gripper', 'Vector1d')])
pp.add('EEPose', [('value', 'Vector3d'), ('rotation', 'Vector3d')])
pp.add('Washer', [('geom', 'Washer'), ('pose', 'Vector3d'), ('rotation', 'Vector3d'), ('door', 'Vector1d')])
pp.add('WasherPose', [('geom', 'Washer'), ('value', 'Vector3d'), ('rotation', 'Vector3d'), ('door', 'Vector1d')])
pp.add('Obstacle', [('geom', 'Box'), ('pose', 'Vector3d'), ('rotation', 'Vector3d')])
pp.add('Rotation', [('value', 'Vector1d')])
pp.add('Can', [('geom', 'Can'), ('pose', 'Vector3d'), ('rotation', 'Vector3d')])
pp.add('CanTarget', [('value', 'Vector3d'), ('rotation', 'Vector3d')])
pp.add('Region', [('value', 'Vector2d')])
pp.add('Edge', [('geom', 'Edge'), ('pose', 'Vector3d'), ('rotation', 'Vector3d'), ('length', 'Vector1d')])
dom_str += pp.get_str() + '\n\n'

class DerivatedPredicates(object):
    def __init__(self):
        self.pred_dict = {}

    def add(self, name, args):
        self.pred_dict[name] = args

    def get_str(self):
        prim_str = 'Derived Predicates: '

        first = True
        for name, args in self.pred_dict.iteritems():
            pred_str = name
            for arg in args:
                pred_str += ', ' + arg

            if first:
                prim_str += pred_str
                first = False
            else:
                prim_str += '; ' + pred_str
        return prim_str

dp = DerivatedPredicates()
dp.add('HSRRobotAt', ['Robot', 'RobotPose'])
dp.add('HSRCanAt', ['Can', 'CanTarget'])
dp.add('HSRTargetsStacked', ['CanTarget', 'CanTarget'])
dp.add('HSRTargetCanStacked', ['Can', 'CanTarget'])
dp.add('HSRCansStacked', ['Can', 'Can'])
dp.add('HSRTargetOnTable', ['Obstacle', 'CanTarget'])
dp.add('HSRIsMP', ['Robot'])
dp.add('HSRWithinJointLimits', ['Robot'])
dp.add('HSRStationaryCan', ['Can'])
dp.add('HSRStationaryNeqCan', ['Can', 'Can'])
dp.add('HSRStationaryBase', ['Robot'])
dp.add('HSRStationaryArm', ['Robot'])
dp.add('HSRStationaryW', ['Obstacle'])
dp.add('HSRGraspValid', ['EEPose'])
dp.add('HSRCanGraspValid', ['EEPose', 'CanTarget'])
dp.add('HSRCloseGripper', ['Robot'])
dp.add('HSROpenGripper', ['Robot'])
dp.add('HSRObstructsCan', ['Robot', 'RobotPose', 'RobotPose', 'Can'])
dp.add('HSRRCollides', ['Robot', 'Obstacle'])
dp.add('HSRRSelfCollides', ['Robot'])
dp.add('HSREEReachableVer', ['Robot', 'RobotPose', 'EEPose'])
dp.add('HSREEReachableHor', ['Robot', 'RobotPose', 'EEPose'])
dp.add('HSRCanInGripper', ['Robot', 'Can'])
dp.add('HSRGripperLevel', ['Robot'])
dp.add('HSRGripperAt', ['Robot', 'EEPose'])

class Action(object):
    def __init__(self, name, timesteps, pre=None, post=None):
        pass

    def to_str(self):
        time_str = ''
        cond_str = '(and '
        for pre, timesteps in self.pre:
            cond_str += pre + ' '
            time_str += timesteps + ' '
        cond_str += ')'

        cond_str += '(and '
        for eff, timesteps in self.eff:
            cond_str += eff + ' '
            time_str += timesteps + ' '
        cond_str += ')'

        return "Action " + self.name + ' ' + str(self.timesteps) + ': ' + self.args + ' ' + cond_str + ' ' + time_str

class Move(Action):
    def __init__(self):
        self.name = 'moveto'
        self.timesteps = 20
        end = self.timesteps - 1
        self.args = '(?robot - Robot ?start - RobotPose ?end - RobotPose)'
        self.pre = [\
            ('(forall (?obj - Basket)\
                (not (BaxterBasketInGripper ?robot ?obj))\
            )', '{}:{}'.format(0, 0)),
            ('(HSRRobotAt ?robot ?start)', '{}:{}'.format(0, 0)),
            ('(HSRGripperLevel ?robot)', '0:{}'.format(end)),
            ('(forall (?obj - Can)\
                (not (HSRObstructsCan ?robot ?start ?end ?obj)))', '{}:{}'.format(0, end-1)),
            ('(forall (?obj - Can)\
                (HSRStationaryCan ?obj))', '{}:{}'.format(0, end-1)),
            ('(forall (?obs - Obstacle) (HSRStationaryW ?obs))', '{}:{}'.format(0, end-1)),
            ('(HSRIsMP ?robot)', '{}:{}'.format(0, end-1)),
            ('(HSRWithinJointLimits ?robot)', '{}:{}'.format(0, end)),
            ('(HSROpenGripper ?robot)', '{}:{}'.format(1, end-1)),
            ('(forall (?w - Obstacle) (not (HSRRCollides ?robot ?w)))', '{}:{}'.format(0, end)),
            ('(not (HSRRSelfCollides ?robot))', '1:{}'.format(end-1)),
        ]
        self.eff = [\
            (' (not (HSRRobotAt ?robot ?start))', '{}:{}'.format(end, end-1)),
            ('(HSRRobotAt ?robot ?end)', '{}:{}'.format(end, end))]

class MoveHoldingCan(Action):
    def __init__(self):
        self.name = 'moveholding_can'
        self.timesteps = 20
        end = self.timesteps - 1
        self.args = '(?robot - Robot ?start - RobotPose ?end - RobotPose ?can - Can)'
        self.pre = [\
            ('(HSRRobotAt ?robot ?start)', '0:0'),
            ('(HSRCanAlmostInGripper ?robot ?can)', '0:0'),
            ('(HSRCloseGripper ?robot)', '1:{}'.format(end)),
            ('(HSRGripperLevel ?robot)', '0:{}'.format(end)),
            ('(forall (?obj - Can)\
                (not (HSRObstructsHolding ?robot ?start ?end ?obj ?can))\
            )', '0:{}'.format(end)),
            ('(forall (?obj - Washer)\
                (not (BaxterCollidesWasher ?robot ?obj)))', '{}:{}'.format(0, end-1)),
            ('(forall (?obj - Can)\
                (HSRStationaryNeqCan ?obj ?can))', '{}:{}'.format(0, end-1)),
            ('(forall (?obs - Obstacle) (HSRStationaryW ?obs))', '0:{}'.format(end-1)),
            ('(HSRIsMP ?robot)', '0:{}'.format(end-1)),
            ('(HSRWithinJointLimits ?robot)', '0:{}'.format(end)),
            ('(not (HSRRSelfCollides ?robot))', '1:{}'.format(end-1)),
            ('(forall (?obs - Obstacle) (not (HSRRCollides ?robot ?obs)))', '0:{}'.format(end))
        ]
        self.eff = [\
            ('(HSRCanInGripper ?robot ?can)', '{}:{}'.format(1, end)),
            ('(not (HSRRobotAt ?robot ?start))', '{}:{}'.format(end, end-1)),
            ('(HSRRobotAt ?robot ?end)', '{}:{}'.format(end, end))
        ]

class MoveHoldingCanToEE(MoveHoldingCan):
    def __init__(self):
        super(MoveHoldingCanToEE, self).__init__()
        self.name = 'moveholding_can_to_ee'
        self.args = '(?robot - Robot ?start - RobotPose ?end - RobotPose ?end_ee - EEPose ?can - Can)'

class CanGrasp(Action):
    def __init__(self):
        self.name = 'can_grasp'
        self.timesteps = 2 * const.EEREACHABLE_STEPS + 11
        end = self.timesteps - 1
        self.args = '(?robot - Robot ?can - Can ?target - CanTarget ?sp - RobotPose ?ee - EEPose ?ep - RobotPose)'
        grasp_time = const.EEREACHABLE_STEPS+5
        approach_time = 5
        retreat_time = end-5
        self.pre = [\
            ('(HSRCanAt ?can ?target)', '1:1'),
            ('(HSRRobotAt ?robot ?sp)', '0:0'),
            ('(HSRGripperLevel ?robot)', '0:{}'.format(end)),
            ('(HSREEReachableVer ?robot ?sp ?ee)', '{}:{}'.format(grasp_time, grasp_time)),
            ('(HSRCanInGripper ?robot ?can)', '{}:{}'.format(grasp_time, end)),
            ('(HSRCanGraspValid ?ee ?target)', '{}:{}'.format(grasp_time, grasp_time)),
            ('(HSROpenGripper ?robot)', '{}:{}'.format(0,  grasp_time-1)),
            ('(HSRCloseGripper ?robot)', '{}:{}'.format(grasp_time,  end)),
            ('(HSRStationaryCan ?can)', '{}:{}'.format(1, grasp_time-1)),
            ('(forall (?obs - Can) (HSRStationaryNeqCan ?obs ?can))', '0:{}'.format(end-1)),
            ('(forall (?obs - Obstacle)\
                (HSRStationaryW ?obs)\
            )', '{}:{}'.format(0, end-1)),
            ('(HSRStationaryBase ?robot)', '{}:{}'.format(0, end-1)),
            ('(HSRIsMP ?robot)', '0:{}'.format(end-1)),
            ('(HSRWithinJointLimits ?robot)', '0:{}'.format(end)),
            ('(not (HSRRSelfCollides ?robot))', '1:{}'.format(end-1)),
            ('(forall (?obs - Obstacle)\
                (not (HSRRCollides ?robot ?obs))\
            )', '0:{}'.format(end)),
        ]
        self.eff = [\
            ('(not (HSRCanAt ?can ?target))', '{}:{}'.format(end, end-1)) ,
            ('(not (HSRRobotAt ?robot ?sp))', '{}:{}'.format(end, end-1)),
            ('(HSRRobotAt ?robot ?ep)', '{}:{}'.format(end, end)),
            ('(HSRCanInGripper ?robot ?can)', '{}:{}'.format(end, end)),
            ('(forall (?sym1 - Robotpose)\
                (forall (?sym2 - RobotPose)\
                    (forall (?obj - Can) (not (HSRObstructsHolding ?robot ?sym1 ?sym2 ?obj ?can)))\
                )\
            )', '{}:{}'.format(1, end))
        ]

class CanPutdown(Action):
    def __init__(self):
        self.name = 'can_putdown'
        self.timesteps = 2 * const.EEREACHABLE_STEPS + 11
        end = self.timesteps - 1
        self.args = '(?robot - Robot ?can - Can ?target - CanTarget ?sp - RobotPose ?ee - EEPose ?ep - RobotPose)'
        putdown_time = const.EEREACHABLE_STEPS+5
        approach_time = 5
        retreat_time = end-5
        self.pre = [\
            ('(HSRRobotAt ?robot ?sp)', '0:0'),
            ('(HSRGripperLevel ?robot)', '0:{}'.format(end)),
            ('(HSREEReachableVer ?robot ?sp ?ee)', '{}:{}'.format(putdown_time, putdown_time)),
            ('(HSRCanInGripper ?robot ?can)', '{}:{}'.format(0, putdown_time)),
            ('(HSRGraspValid ?ee ?target)', '{}:{}'.format(putdown_time, putdown_time)),
            ('(HSROpenGripper ?robot)', '{}:{}'.format(putdown_time,  end)),
            ('(HSRCloseGripper ?robot)', '{}:{}'.format(0,  putdown_time-1)),
            ('(HSRStationaryCan ?can)', '{}:{}'.format(putdown_time, end-1)),            
            ('(forall (?obs - Obstacle)\
                (HSRStationaryW ?obs)\
            )', '{}:{}'.format(0, end-1)),
            ('(forall (?obs - Can) (HSRStationaryNeqCan ?obs ?can))', '0:{}'.format(end-1)),
            ('(HSRStationaryBase ?robot)', '{}:{}'.format(0, end-1)),
            ('(HSRIsMP ?robot)', '0:{}'.format(end-1)),
            ('(HSRWithinJointLimits ?robot)', '0:{}'.format(end)),
            ('(not (HSRRSelfCollides ?robot))', '1:{}'.format(end-1)),
            ('(forall (?obs - Obstacle)\
                (not (HSRRCollides ?robot ?obs))\
            )', '0:{}'.format(end)),
            ('(forall (?obj - Can)\
                (not (HSRObstructsHolding ?robot ?sp ?ep ?obj ?can))\
            )', '{}:{}'.format(0, end))
        ]
        self.eff = [\
            ('(HSRCanAt ?can ?target)', '{}:{}'.format(end, end)),
            ('(not (HSRRobotAt ?robot ?sp))', '{}:{}'.format(end, end-1)),
            ('(HSRRobotAt ?robot ?ep)', '{}:{}'.format(end, end)),
            ('(not (HSRCanInGripper ?robot ?can))', '{}:{}'.format(end, end)),
        ]

class StackCans(Action):
    def __init__(self):
        self.name = 'stack_cans'
        self.timesteps = 2 * const.EEREACHABLE_STEPS + 11
        end = self.timesteps - 1
        self.args = '(?robot - Robot ?held_can - Can ?target - CanTarget ?bottom_can - Can ?sp - RobotPose ?ee - EEPose ?ep - RobotPose)'
        putdown_time = const.EEREACHABLE_STEPS+5
        approach_time = 5
        retreat_time = end-5
        self.pre = [\
            ('(HSRRobotAt ?robot ?sp)', '0:0'),
            ('(HSRTargetCanStacked ?bottom_can ?target)', '{}:{}'.format(0, 0)),
            ('(HSRGripperLevel ?robot)', '0:{}'.format(end)),
            ('(HSREEReachableVer ?robot ?sp ?ee)', '{}:{}'.format(putdown_time, putdown_time)),
            ('(HSRCanInGripper ?robot ?held_can)', '{}:{}'.format(0, putdown_time)),
            ('(HSRGraspValid ?ee ?target)', '{}:{}'.format(putdown_time, putdown_time)),
            ('(HSROpenGripper ?robot)', '{}:{}'.format(putdown_time,  end)),
            ('(HSRCloseGripper ?robot)', '{}:{}'.format(0,  putdown_time-1)),
            ('(HSRStationaryCan ?held_can)', '{}:{}'.format(putdown_time, end-1)),            
            ('(forall (?obs - Obstacle)\
                (HSRStationaryW ?obs)\
            )', '{}:{}'.format(0, end-1)),
            ('(forall (?obs - Can) (HSRStationaryNeqCan ?obs ?held_can))', '0:{}'.format(end-1)),
            ('(HSRStationaryBase ?robot)', '{}:{}'.format(0, end-1)),
            ('(HSRIsMP ?robot)', '0:{}'.format(end-1)),
            ('(HSRWithinJointLimits ?robot)', '0:{}'.format(end)),
            ('(not (HSRRSelfCollides ?robot))', '1:{}'.format(end-1)),
            ('(forall (?obs - Obstacle)\
                (not (HSRRCollides ?robot ?obs))\
            )', '0:{}'.format(end)),
            ('(forall (?obj - Can)\
                (not (HSRObstructsHolding ?robot ?sp ?ep ?obj ?held_can))\
            )', '{}:{}'.format(0, end))
        ]
        self.eff = [\
            ('(HSRCanAt ?held_can ?target)', '{}:{}'.format(end, end)),
            ('(HSRCansStacked ?held_can ?bottom_can)', '{}:{}'.format(end, end-1)),
            ('(not (HSRRobotAt ?robot ?sp))', '{}:{}'.format(end, end-1)),
            ('(HSRRobotAt ?robot ?ep)', '{}:{}'.format(end, end)),
            ('(not (HSRCanInGripper ?robot ?held_can))', '{}:{}'.format(end, end)),
        ]